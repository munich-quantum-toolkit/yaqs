# Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
# All rights reserved.
#
# SPDX-License-Identifier: MIT
#
# Licensed under the MIT License

"""Fast Matrix Exponential Methods.

This module implements matrix-free methods for approximating the action of a matrix exponential
on a vector via Krylov subspace techniques. It provides an implementation of the Lanczos iteration
to generate an orthonormal basis for the Krylov subspace, and uses this basis to compute an
approximation of exp(-1j * dt * A) * v without explicitly constructing the matrix A.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
import scipy.linalg

if TYPE_CHECKING:
    from collections.abc import Callable

    from numpy.typing import NDArray


def lanczos_iteration(
    matrix_free_operator: Callable[[NDArray[np.complex128]], NDArray[np.complex128]],
    vec: NDArray[np.complex128],
    lanczos_iterations: int,
) -> tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.complex128]]:
    """Perform a matrix-free Lanczos iteration.

    This function generates an orthonormal basis for the Krylov subspace of the operator defined
    by matrix_free_operator using the Lanczos algorithm. It computes the diagonal (alpha) and off-diagonal (beta)
    elements of the tridiagonal (Hessenberg) matrix associated with the iteration and returns the
    matrix whose columns are the Lanczos vectors.

    Args:
        matrix_free_operator (Callable[[NDArray[np.complex128]], NDArray[np.complex128]]):
            A function that applies a linear transformation to a vector without explicitly constructing
            the matrix (i.e., matrix-free).
        vec (NDArray[np.complex128]):
            The starting vector for the Lanczos iteration. This vector is normalized in place.
        lanczos_iterations (int):
            The number of Lanczos iterations to perform. It should be much smaller than the dimension of
            vec.

    Returns:
        tuple:
            - alpha (NDArray[np.float64]): Array of length lanczos_iterations containing the diagonal entries of the
              tridiagonal matrix.
            - beta (NDArray[np.float64]): Array of length lanczos_iterations-1 containing the off-diagonal entries.
            - lanczos_mat (NDArray[np.complex128]): A matrix of shape (len(vec) x lanczos_iterations) whose
              columns are the orthonormal Lanczos vectors.

    Raises:
        ValueError: If the starting vector has zero norm.
    """
    v0 = np.array(vec, dtype=np.complex128, copy=True)
    nrm = np.linalg.norm(v0)
    if nrm == 0:
        msg = "Starting vector has zero norm."
        raise ValueError(msg)
    v0 /= nrm

    m = lanczos_iterations
    alpha = np.zeros(m, dtype=np.float64)
    beta = np.zeros(m - 1, dtype=np.float64)

    # Store basis as (n, m): V[:, j] is contiguous and BLAS-friendly
    v = np.zeros((v0.size, m), dtype=np.complex128)
    v[:, 0] = v0

    eps_cut = 100.0 * v0.size * np.finfo(np.float64).eps

    for j in range(m - 1):
        vj = v[:, j]
        w = matrix_free_operator(vj)  # expect shape (n,)

        # alpha_j = <v_j, w>
        aj = np.vdot(vj, w).real
        alpha[j] = aj

        # w <- w - aj*vj - beta_{j-1}*v_{j-1}
        w -= aj * vj
        if j > 0:
            w -= beta[j - 1] * v[:, j - 1]

        bj = np.linalg.norm(w)
        beta[j] = bj

        if bj < eps_cut:
            # Early termination: return truncated basis
            k = j + 1
            return alpha[:k], beta[: k - 1], v[:, :k]

        v[:, j + 1] = w / bj

    # Final alpha_{m-1}
    vj = v[:, m - 1]
    w = matrix_free_operator(vj)
    alpha[m - 1] = np.vdot(vj, w).real
    return alpha, beta, v


def expm_krylov(
    matrix_free_operator: Callable[[NDArray[np.complex128]], NDArray[np.complex128]],
    vec: NDArray[np.complex128],
    dt: float,
    lanczos_iterations: int,
) -> NDArray[np.complex128]:
    """Compute the Krylov subspace approximation of the matrix exponential applied to a vector.

    This function approximates exp(-1j * dt * A) * v by projecting the action of the matrix exponential
    onto a Krylov subspace generated by the Lanczos iteration. The method is based on the approach
    described by Hochbruck and Lubich.

    Args:
        matrix_free_operator (Callable[[NDArray[np.complex128]], NDArray[np.complex128]]):
            A function implementing the matrix-free application of the linear operator A.
        vec (NDArray[np.complex128]):
            The input vector to which the matrix exponential is applied.
        dt (float):
            The time step (or scalar multiplier) in the exponential.
        lanczos_iterations (int):
            The number of Lanczos iterations (and the dimension of the Krylov subspace) to use.

    Returns:
        NDArray[np.complex128]:
            The approximate result of applying exp(-1j * dt * A) to vec.
    """
    vec_norm = np.linalg.norm(vec)
    alpha, beta, lanczos_mat = lanczos_iteration(matrix_free_operator, vec, lanczos_iterations)
    try:
        w_hess, u_hess = scipy.linalg.eigh_tridiagonal(
            alpha,
            beta,
            lapack_driver="stemr",
            check_finite=False,
        )
    except scipy.linalg.LinAlgError:
        w_hess, u_hess = scipy.linalg.eigh_tridiagonal(
            alpha,
            beta,
            lapack_driver="stebz",
            check_finite=False,
        )

    # Construct the approximation: scale the exponential of the eigenvalues by the norm of v,
    # and project back to the full space via the Lanczos basis V.
    coeffs = vec_norm * np.exp(-1j * dt * w_hess) * u_hess[0]

    return np.asarray(lanczos_mat @ (u_hess @ coeffs), dtype=np.complex128)
